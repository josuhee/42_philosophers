eating
thinking
sleeping

생존시간 안에 밥먹기


철학자, die, eat, sleep, must_eat


[mandatory]
- 1명 이상의 철학자가 원탁에 앉아 세 가지 중 하나를 한다.(eating, thinking, sleeping)
- 먹는 동안에는 생각을 하거나 잠을 자지 않고, 자는 동안에는 먹거나 생각하지 않으며, 생각하는 동안에는 먹거나 잠을 자지 않는다.
- 철학자들은 커다란 스파게티 그릇을 중앙에 두고 원형 테이블에 앉는다.
- 테이블 위에는 포크가 몇 개가 있다.
- 철학자는 한 손에 포크 하나씩 들어서 스파게티를 먹을 수 있다. 즉, 1철학자 2포크가 필요하다.
- 철학자들은 절대 굶주리지 않아야 한다.
- 모든 철학자는 먹어야 한다.
- 철학자들은 서로 말을 하지 않는다.
- 철학자는 다른 철학자가 언제 죽은지 모른다.
- 철학자는 식사를 마칠 때마다 포크를 떨어뜨리고 잠을 자기 시작한다.
- 잠을 다 자고 나면 생각하기 시작한다.(thinking)
- 철학자가 죽으면 시뮬레이션(프로그램)이 종료된다.
- 아래와 같은 오퍼레이션이 있어야함.(argu)
* number_of_philosophers :   철학자의 수
* time_to_die : 철학자가 마지막 식사를 하거나 프로그램이 시작한 후 'time_to_die'를 먹지 않으면 사망한다.
* time_to_eat : 철학자가 먹는 데 걸리는 시간이다. 그 시간 동안 그는 두 개의 포크를 보관한다.
* time_to_sleep : 철학자가 자는 시간
* number_of_times_each_philosopher_must_eat : 모든 철학자가 적어도 이만큼 먹는 경우. 선택사항임. 명시되지 않는다면 프로그램은 철학자의 죽음에서만 중단된다.

- 철학자에게는 1부터 번호를 부여한다.
- 숫자 N을 가진 철학자는 N - 1과 철학자 N + 1 사이에 앉는다.
- 철학자의 모든 상태 변경은 다음과 같이 작성되어야 한다.
* timestamp X has taken a fork
* timestamp X is eating
* timestamp X is sleeping
* timestamp X is thinking
* timestamp X died
- 인쇄된 지위가 다른 철학자의 지위와 뒤엉키거나 얽혀서는 안된다.
- 철학자의 죽음과 그 죽음을 인쇄할 시간 사이에는 10ms를 초과할 수 없다.

- 각 철학자들 사이에 하나의 갈림길이 있기 때문에 그들이 여러 철학자들이라면 각 철학자들의 오른쪽과 왼쪽에는 갈림길이 있을 것이다.
- 철학자가 포크를 복제하지 않도록 각 포크의 뮤텍스로 포크 상태를 보호해야한다.
- 각각의 철학자는 쓰레드로 이루어져야 한다.



[사용 가능 함수]
- printf
- memset
- malloc
- free
- write
- usleep
- gettimeofday
- pthread_create
- pthread_detach
- pthread_join
- pthread_mutex_init
- pthread_mutex_destory
- pthread_mutex_lock
- pthread_mutex_unlock

[구현 목록]
- 모니터 (죽은 철학자 유무, must_eat 유무)
- 각 철학자 마다 쓰레드 주기.
- 먹고
- 자고
- 생각하고


[프로세스]
1. 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램


[스레드]
1. CPU 이용의 기본 단위
2. 스레드ID, 프로그램 카운터(PC), 레지스터 집합, 스택으로 구성된다.
3. 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 열린 파일이나 신호와 같은 운영체제 자원들을 공유한다.
4. 프로세스 내에서 실행되는 여러 흐름의 단위

*장점
- 응답성 reponsiveness
대화형 응용을 다중 스레드화 하면 응용 프로그램의 일부분이 봉쇄되거나, 응용 프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속 되는 것을 허용함으로써, 사용자에 대한 응답성을 증가시킨다. 이 특징은 사용자 인터페이스를 설계하는 데 있어 유용하다.
- 자원 공유 resource sharing
한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다는 장점이 있다.
- 경제성 economy
프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다. 그러나 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 문맥 교환 하는 것이 더욱더 경제적이다.
- 규모 적응성 scalability
다중 처리기 구조에서는 각각의 스레드가 다른 처리기에서 병렬로 수행될 수 있다.
